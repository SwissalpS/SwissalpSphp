<?php/* * * * * * SssS_SocketController.inc * * intended for command line scripts to include and build on * * * * manages a port and spawns children processes to manage other ports * * stays in contact with it's children by connecting to them right after * * starting them up * * * * written while writing a chat room server with child servers for private rooms * * * * @version 20100429_103006 !!new way of logging on!! not backward compatible * * @version 20091103_075730 /run, runf, get, set (basic strings work) -> first demo launch * * @version 20091024_000622 (CC) Luke JZ aka SwissalpS * * * */if (!defined('AUTO_INCLUDING')) {	require_once('SssS_PIDlock.inc');	require_once('SssS_PlistPrefs.inc'); // extends _Plist extends _Xtend  extends _XHTML (extends WF_Object planed)	require_once('SssS_AnsiEscapes.inc');	require_once('SssS_TextDecorator.inc');	require_once('SssS_PHPinlineScriptRunner.inc'); // a subclass of SssS_ShellScriptRunner	//require_once('SssS_TranslatorEmoticons.inc'); // actually a subclass of this gal	require_once('SssS_ServerCommander.inc'); // actually a subclass of SssS_Commander	require_once('SssS_ChatClient.inc'); // a subclass of SssS_PlistPrefs storing settings and history etc of users	require_once('SssS_ChatLogonClient.inc'); // a subclass of SssS_ChatClient as subclass of SssS_Plist} // if not autoincluding but on php's include pathclass SssS_SocketController {	const COMM_CHAR_INTERNAL	= '/';	const COMM_CHAR_PHP			= '$';	const COMM_CHAR_RUNF		= '#';	private static $aPerms = array(			'CREATOR'	=> 4096,	// programer may do anything			'MURPHY'	=> 2048,	// sysadmin or some other power figure			'PRESIDENT'	=> 1024,	// reseller?			'LANDLORD'	=> 512,		// paying client?			'LANDFE'	=> 256,		// http frontend to the virtual cluster			'ROOMFE'	=> 128,		// http frontend to the room (when not acting on behalf)			'ROOMOWNER'	=> 64,		// initiator of room or one given these perms			'GRANTER'	=> 32,		// grant others perms, change their display			'CYPHER'	=> 16,		// toggle encryption of room, block logging			'GUARD'		=> 8,		// may kick, deny access			'INVITER'	=> 4,		// invite others to room			'GUEST'		=> 2,		// standard user may logout change name etc.			'NOID'		=> 1,		// during logon			'BLOCKED'	=> 0,		// blocked user			);	var $oPrefs		= null; // the preferences manager with file rep it	var $oPID		= null; // the pid locking controller object	var $oPusers	= null; // the object holding a list of all UIDs allowed in	var $aUo		= array(); // array holding the users (sync keys with above)	var $aUoLogons	= array(); // array holding user objects that are connected but not yet identified added 20100429_103006	var $oCommander = null; // command translator	var $oEmmotion	= null; // emoticon etc handler	var $bInitiated = null; // is server initiated	var $bRunning	= null; // are we online	var $rSocket	= null; // primary socket resource handle	var $sUIDroom	= null; // the rooms uid	var $iDebugLevel;		// read from settings. output level on std out	protected $bInKillLoop = false;	/**	 * SssS_SocketController($sSettingsPlistPath = 'data/config.plist')	 * Function_description_here	 *	 * @param string $sSettingsPlistPath plist holding all the settings (defaults to: 'data/config.plist')	 *	 * @return object or terminates if can't initialize or pid is locked etc.	 *	 *	 * @uses something - uses_desciption_here	 *	 * @version 20091024_002129 (CC)2007 Luke JZ aka SwissalpS	 */	public function SssS_SocketController($sSettingsPlistPath = 'data/config.plist') {		// init the prefs or die		$this->initPrefs($sSettingsPlistPath);		// check pid lock and die if already running		$this->pidLock();		// init users		$this->initUsers();		// init commands array hash		$this->initCommands();		// init smiles seems to be the job of a subclass, but we'll call anyway		// to make it easier for subclassing		$this->initEmoticons();		// init myself		$this->initServer();		// connect to parent if any		$this->connectParent();		// and run		$this->run();	} // SssS_SocketController	private function acceptClient($bBlock = true, $sMsg = null) {		if (!$bBlock) {			socket_set_nonblock($this->rSocket);			// @ is important here!!!! you can crash your server in seconds			//   if you don't. We are running a tight loop -> warnings would			//   overflow the server!!!			$mRes = @socket_accept($this->rSocket);		} else {			// spawn another socket to handle communication			$mRes = @socket_accept($this->rSocket) or $this->shutdown(					"\n" . '		failed to accept client' . "\n" . '211');		} // if blocking or nonblocking mode		socket_set_block($this->rSocket);		// detect what type of client (humanoids wait for prompt others tend to ask straight away)		if (false !== $mRes) $this->detectClientTypeAndDirect($mRes); //logon($mRes);	} // acceptClient	function connectParent() {		// connect to parent if any		// ask for lineup?		$this->requestLinup();	} // connectParent	function dealWithHTTP($rSpawn, $sInput = '') {		// wrong protocol :-\		// just kick silently		//@socket_close($rSpawn); return;		// or respond with denial or redirection		//$sResponse = self::headerResponseHTTP(530); // '530 User access denied' . "\r\n");		//$sResponse = self::headerResponseHTTP(418); // '418 I'm a teapot' . chr(13) . chr(10)		$sResponse = self::headerResponseHTTP(301, $sSomeUrl = $this->oPrefs->getOrSet(				'lang/en/logonDefaultBrowserRedirectURL',				'http://lukezimmermann.com/')); // '301 Moved Permanently' . chr(13) . chr(10)		//$sResponse = self::headerResponseHTTP(202) . '<html><body><a href="http://somewhere.lov:80" >Followme</a>' . chr(13) . chr(10);		socket_getpeername($rSpawn, $sRemIP);		$this->write2resource($rSpawn, $sResponse);		if (3 < $this->oPrefs->get('debugLevel'))				echo 'redirecting browser IP: '				. $sRemIP				. "\n";		@socket_close($rSpawn);	} // dealWithHTTP	function detectClientTypeAndDirect($rSpawn) {		$sInput = null;		// read if there is anything - @ is important here		$mRes = @socket_recv($rSpawn, $sInput, 1024, MSG_DONTWAIT);		// did we get something?		if (false !== $mRes) $sInput = trim($sInput); // yes -> trim		if (!empty($sInput)) {			// got input			// possibly a browser? or other client?			if (self::isHTTPrequest($sInput))					return $this->dealWithHTTP($rSpawn, $sInput);			else return $this->logon($rSpawn, $sInput);		} // if got input		// if there was a connection request, we'll log him on and pause the rest		// 20100429_103006 changed behaviour to just check black & white lists		// add as anonymous to array		$this->logon($rSpawn);	} // detectClientTypeAndDirect	static function headerResponseHTTP($iCode = 418, $sUrl = '') {		static $nl = null; if (!$nl) $nl = chr(13) . chr(10);		$sOut = 'HTTP/1.0 ';		switch ($iCode) {			case 530: $sOut .= '530 User access denied';				break;			case 418: $sOut .= '418 I\'m a teapot';				break;			case 301: $sOut .= '301 Moved Permanently' . $nl					. 'Location: ' . $sUrl;				break;			default:			$sOut .= $iCode . ' ';			switch(intval($iCode / 100) * 100) {				case 100: $sOut .= 'Some Info';				break;				case 200: $sOut .= 'OK' . $nl . 'Date: ' . gmdate('r'); // size, enc....				break;				case 300: $sOut .= 'Some Redirection' . $nl . 'Location: ' . $sUrl;				break;				case 400: $sOut .= 'Some User Error';				break;				case 500:  $sOut .= 'Some Server Error';				break;				default: $sOut .= 'Something';			} // switch level		} // switch code		$sOut .= $nl . $nl . $nl;		return $sOut;	} // headerResponseHTTP	function iDebugLevel() {		return $this->oPrefs->get('iDebugLevel', 7);	} // iDebugLevel	function initCommands() {		if ($this->oCommander) return;		// attempt to initialize prefs if not yet done and die if can't		$this->initPrefs();		echo SssS_TextDecorator::indentLines('initializing commander...', 5)				. "\n";		$sCommander = $this->oPrefs->getOrSet(				'paths/commandsPath', 'data/commands.plist');		$this->oCommander = new SssS_ServerCommander($sCommander, $this);		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'initialized commander from', 'neutral')), 5)				. ": $sCommander\n\n";		unset($sCommander);	} // initCommands	function initEmoticons() {		// TODO:	} // initEmoticons	function initPrefs($sSettingsPlistPath = 'data/config.plist') {		// already instantiated? go home!		if ($this->oPrefs) return;		echo SssS_TextDecorator::indentLines('initializing prefsDB...', 5)				. "\n";		// init the prefs or die		$this->oPrefs = new SssS_PlistPrefs($sSettingsPlistPath);		$this->oPrefs->getOrSet('debugLevel', 7); // TODO: 0 IN PRODUCTION		$this->oPrefs->getOrSet('iSetTimeLimit', 0); // timeout for timed sessions		$this->sUIDroom = $this->oPrefs->getOrSet('myDetails/roomUID', 'lobby');		$this->oPrefs->getOrSet('mySocket/maxClients', 5);		$this->oPrefs->getOrSet('mySocket/iProtocolFamily', AF_INET);		$this->oPrefs->getOrSet('mySocket/iType', SOCK_STREAM);		$this->oPrefs->getOrSet('mySocket/iProtocol', 0);		$sHost = $this->oPrefs->getOrSet('mySocket/host', 'localhost'); //'127.0.0.1'		$iPort = $this->oPrefs->getOrSet('mySocket/port', 49494); // +100 = 49594 // 494949 didn't work on urox 495049		$this->oPrefs->getOrSet('myParent/host', $sHost);		$this->oPrefs->getOrSet('myParent/port', -1); // neg => no parent // 494950		$this->oPrefs->getOrSet('myChildren/hostPool/' . $sHost . '/iStartPort', $iPort + 2);		$this->oPrefs->getOrSet('myChildren/hostPool/' . $sHost . '/iMaxAmount', 98);		//$this->oPrefs->set('myChildren/hostPool/', array()); // for no children, all rooms run thru here -> probably would then be working with a filter system or addressing		$this->oPrefs->getOrSet('myChildren/bAllowMultipleOnSamePort', true); // provided they are of the same kind, but I think we will have audio on separate thread all together, but I hope they will be subclasses of this system so they will be able to connect here and we can ask them to play other stuff or change playlist....		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'initialized prefsDB', 'neutral')), 5)				. ": $sSettingsPlistPath\n\n";	} // initPrefs	function initServer() {		if ($this->bInitiated) return;		// don't timeout or take what's in the config.plist		set_time_limit($this->oPrefs->get('iSetTimeLimit'));		// TODO: start a timer here so we can shutdown before...well then we could set to 0 and time ourselves anyway		// do some logging		echo implode("\n", SssS_TextDecorator::centeredTextPages('               '. SssS_AnsiEscapes::flatten(array('bold', gmdate('Ymd h:i:s'),				'neutral', "\n", 'blackOnGreen', $this->sUIDroom, 'neutral',				' roomServer starting up' . "\n"				. 'My PID is: ', 'blackOnGreen', 'bold', $this->oPID->getPID(),				'neutral', "\n" . 'PID file: ', 'bold', 'blackOnGreen',				$this->oPID->getPIDLockPathFile(), 'neutral')))) . "\n";		// create socket or shutdown		$this->rSocket = @socket_create(			$this->oPrefs->get('mySocket/iProtocolFamily', AF_INET),			$this->oPrefs->get('mySocket/iType', SOCK_STREAM),			$this->oPrefs->get('mySocket/iProtocol', 0))				or $this->shutdown(SssS_AnsiEscapes::gimme('blinking')						. SssS_AnsiEscapes::gimme('bold')						. SssS_AnsiEscapes::gimme('yellowOnRed')						. "Could not create socket. Exiting\n"						. SssS_AnsiEscapes::gimme());		$this->bInitiated = true;		echo implode("\n", SssS_TextDecorator::centeredTextPages(				'created socket...binding...')) . "\n";		$sHost = $this->oPrefs->get('mySocket/host', 'localhost'); //'127.0.0.1'		$iPort = $this->oPrefs->get('mySocket/port', 494949); // 495049		// bind socket to assigned port or shutdown		$bResult = @socket_bind($this->rSocket, $sHost, $iPort)				or $this->shutdown(SssS_AnsiEscapes::gimme('blinking')						. SssS_AnsiEscapes::gimme('bold')						. SssS_AnsiEscapes::gimme('cyanOnRed')						. "\nCould not bind to socket. Exiting\n"						. SssS_AnsiEscapes::gimme());		echo implode("\n", SssS_TextDecorator::centeredTextPages(				'socket is bound....start listening...')) . "\n";		// start listening for connections		$bResult = @socket_listen($this->rSocket,				$this->oPrefs->get('mySocket/maxClients'))						or $this->shutdown(SssS_AnsiEscapes::gimme('blinking')						. SssS_AnsiEscapes::gimme('boldYellow')						. SssS_AnsiEscapes::gimme('yellowOnMagenta')						. "\nCould not set up socket listener. Exiting\n"						. SssS_AnsiEscapes::gimme());		echo implode("\n", SssS_TextDecorator::centeredTextPages(				'socket is listening, resetting client count....')) . "\n";		$this->oPrefs->set('iCountClients', (int)0);		// accept incoming connections		echo implode("\n", SssS_TextDecorator::centeredTextPages(				SssS_AnsiEscapes::gimme('bold')				. SssS_AnsiEscapes::gimme('blackOnGreen')				. 'Waiting for connections @'				. $this->oPrefs->get('mySocket/host') . ':'				. $this->oPrefs->get('mySocket/port')				. SssS_AnsiEscapes::gimme())) . "\n";	} // initServer	function initUsers() {		// already instantiated? go home!		if ($this->oPusers) return;		// attempt to initialize prefs if not yet done and die if can't		$this->initPrefs();		echo SssS_TextDecorator::indentLines('initializing userDB...', 5)				. "\n";		// get user settings if available, else set to minimum structure		$sPusers = $this->oPrefs->getOrSet('paths/userPrefs' // key path				, 'data/rooms/' . $this->sUIDroom . '_userList.plist'); 		// default value		// get our sandbox path where user data would be written to...		$sClientsPath = $this->oPrefs->getOrSet(				'paths/userSandbox', 'data/users'); // keyPath, Value		// make sure there's a trailing /		$sClientsPath .= (('/' == substr($sClientsPath, -1)) ? '' : '/');		// init user list or die		$this->oPusers = new SssS_PlistPrefs($sPusers);		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'initialized userDB', 'neutral')), 5)				. "\n\n";		// get the list of uids from the object		$aUIDs = $this->oPusers->get();		// make sure we have at least 2 ways of killing room		$bGotRoomFE = false; $bGotRoomOwner = false;		$sUIDroomFE = $this->oPrefs->getOrSet(				'myDetails/superUIDs/roomFE', 'Room0frontEnd');		$sUIDroomOwner = $this->oPrefs->getOrSet(				'myDetails/superUIDs/owner', 'Room0frontEnd');		// while developing we also want a creator and murphy		$sUIDmurphy = $this->oPrefs->getOrSet(				'myDetails/superUIDs/murphy', 'zen');		$bGotGod = false; $bGotMurphy = false; $sUIDgod = 'luke';		// instantiate the users		foreach ($aUIDs as $sUID) {			$sNewClientsPath = $sClientsPath . 'u' . $sUID . '.plist';			// loads from disk if available or tries to write or dies			$oNewClient = new SssS_ChatClient($sNewClientsPath, $this);			// make sure uid is set and same as servers array and user filename			$oNewClient->set('uid', $sUID);			// also make sure resource handles are nulled			$oNewClient->setResourceHandle();			echo SssS_TextDecorator::indentLines('uid: ' . $sUID					. ' initialized as ' . $oNewClient->name() . "\n"					. ' nulled resource Handle, checking permissions...', 5)					. "\n";			// add to our array of user objects			$this->aUo[$sUID] = $oNewClient;			// verify permissions			$aPermissions = $oNewClient->get('permissions');			if (isset($aPermissions[$this->sUIDroom])) {				if (SssS_SocketController::$aPerms['ROOMFE'] & $aPermissions[$this->sUIDroom])							$bGotRoomFE = true;				if (SssS_SocketController::$aPerms['ROOMOWNER'] & $aPermissions[$this->sUIDroom])							$bGotRoomOwner = true;			} elseif (isset($aPermissions['system'])					&& (SssS_SocketController::$aPerms['LANDLORD'] <= $aPermissions['system'])) {				// might be a user with system wide permission settings				if (SssS_SocketController::$aPerms['CREATOR'] & $aPermissions['system']) {					$bGotGod = true;					//$oNewClient->oSandBox = new SssS_Sandbox();					//$oNewClient->oShellPHP = new SssS_PHPinlineScriptRunner($oNewClient->oSandBox);				} elseif (SssS_SocketController::$aPerms['MURPHY'] & $aPermissions['system']) {					$bGotMurphy = true;					//$oNewClient->oSandBox = new SssS_Sandbox();					//$oNewClient->oShellPHP = new SssS_PHPinlineScriptRunner($oNewClient->oSandBox);				} // got god or murphy remember god is also murphy			} else {				// what's it doing on my list?				trigger_error('user uid: ' . $sUID						. ' has no permissions for this room uid: ' . $this->sUIDroom,						E_USER_NOTICE);				unset($this->aUo[$sUID]);				echo SssS_TextDecorator::indentLines(implode("\n",						SssS_TextDecorator::centeredTextPages(						'user is on my list but he'						. ' has no permissions for my room' . "\n"						. '   I released him, but left him on the list.', ' ',						52, 24, -20)), 5) . "\n";			} // if got permissions for this room -> should be		} // foreach user		if (!$bGotGod) {			$sNewClientsPath = $sClientsPath . 'u' . $sUIDgod . '.plist';			$oNewClient = new SssS_ChatClient($sNewClientsPath, $this);			$oNewClient->set('permissions', array('system' => 80191));			$oNewClient->set('name', 'SwissalpS');			$oNewClient->set('uid', $sUIDgod);			$oNewClient->set('colourEscape', 'boldMagenta');			$this->aUo[$sUIDgod] = $oNewClient;			echo "\n" . SssS_TextDecorator::indentLines(implode("\n",						SssS_TextDecorator::centeredTextPages(					'there was no god, so I created him uid: ' . $sUIDgod					. ' initialized as ' . $oNewClient->name(), ' ',						52, 24, -20)), 5) . "\n";		} // if no god		if (!$bGotMurphy) {			$sNewClientsPath = $sClientsPath . 'u' . $sUIDmurphy . '.plist';			$oNewClient = new SssS_ChatClient($sNewClientsPath, $this);			$oNewClient->set('permissions', array('system' => 4095));			$oNewClient->set('name', 'Zenox');			$oNewClient->set('uid', $sUIDmurphy);			$oNewClient->set('colourEscape', 'boldGreen');			$this->aUo[$sUIDmurphy] = $oNewClient;			echo "\n" . SssS_TextDecorator::indentLines(implode("\n",						SssS_TextDecorator::centeredTextPages(					'there was no murphy, so I carved him uid: ' . $sUIDmurphy					. ' initialized as ' . $oNewClient->name(), ' ',						52, 24, -20)), 5) . "\n";		} // if no		if (!$bGotRoomOwner) {			$sNewClientsPath = $sClientsPath . 'u' . $sUIDroomOwner . '.plist';			$oNewClient = new SssS_ChatClient($sNewClientsPath, $this);			$oNewClient->set('permissions', array($this->sUIDroom => 127));			$oNewClient->set('name', 'RoomOwner');			$oNewClient->set('uid', $sUIDroomOwner);			$this->aUo[$sUIDroomOwner] = $oNewClient;			echo "\n" . SssS_TextDecorator::indentLines(implode("\n",						SssS_TextDecorator::centeredTextPages(					'there was no room owner, so I announced uid: ' . $sUIDroomOwner					. ' initialized as ' . $oNewClient->name(), ' ',						52, 24, -20)), 5) . "\n";		} // if no		if (!$bGotRoomFE) {			$sNewClientsPath = $sClientsPath . 'u' . $sUIDroomFE . '.plist';			$oNewClient = new SssS_ChatClient($sNewClientsPath, $this);			$oNewClient->set('permissions', array($this->sUIDroom => 255));			$oNewClient->set('name', 'RoomFrontEnd');			$oNewClient->set('uid', $sUIDroomFE);			$this->aUo[$sUIDroomFE] = $oNewClient;			echo "\n" . SssS_TextDecorator::indentLines(implode("\n",						SssS_TextDecorator::centeredTextPages(					'there was no "RoomFrontEnd", so I defined uid: ' . $sUIDroomFE					. ' initialized as ' . $oNewClient->name(), ' ',						52, 24, -20)), 5) . "\n";		} // if no		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'initialized users aka done',				'neutral')), 5)	. "\n\n";		unset($sUID, $aUIDs, $sPusers, $sClientsPath, $sNewClientsPath, $oNewClient);	} // initUsers	function kickUser($sUID) {		// valid uid?		if (!isset($this->aUo[$sUID]))				return "\n" . 'invalid uid' . "\n" . '101';		// user connected		$oUser = $this->aUo[$sUID];		if (!$oUser || !$oUser->isConnected())				return "\n" . 'user isn\'t here' . "\n" . '102';		// TODO: if last superuser don't allow to go unless we are in the kill loop		if (!$this->bInKillLoop) {		} // if check if got at least one killer connected		// prepare the good byes		$sGoodBye = sprintf("\n" . $this->oPrefs->getOrSet(				'lang/en/byeUserFormat', 'Good bye %1$s') . "\n", $oUser->name());		$sLogOffMsg = sprintf("\n" . $this->oPrefs->getOrSet(				'lang/en/userHasLeftFormat', '%1$s has left the building') . "\n",						$oUser->name());		// and say them, first to the leaving user then to all		$this->write2Client($sUID, $sGoodBye);		// close the connection @ just in case it already quit		@socket_close($oUser->resourceHandle());		$this->tellEveryOneExcept(array($sUID), $sLogOffMsg);		// unlog the user		$oUser->setResourceHandle(null);		// make sure history is flushed when room wants it that way		if ($this->oPrefs->getOrSet('forceFlushOnExit', true))				$oUser->set('flushHistoryOnExit', true);		// save his settings and history depending on his and global settings		$oUser->save();		// TODO: tell parent server that user quit		unset($oUser, $sGoodBye, $sLogOffMsg);		return "\n" . 'kicked user: ' . $sUID . "\n";	} // kickUser	function logon($rSpawn, $sInput = '') {		// console/log msg		if (3 < $this->oPrefs->get('debugLevel'))				echo "\nReceived connection request\n";		// notify all of a break		$this->tellEveryOneExcept(array(),				"\n" . $this->oPrefs->getOrSet('lang/en/broadcastWait4logon',						'   --- knock, knock ---'). "\n");		// check validity step 1 -> IP get		$bRes	= @socket_getpeername($rSpawn, $sRemIP);		if (!$bRes) {			$sMsg = $this->oPrefs->getOrSet('lang/en/goodbyeErrorGettingIP',					' sorry, we could not determine your IP. Good bye. ') . "\n";			$this->write2resource($rSpawn, $sMsg);			@socket_close($rSpawn);			$this->tellEveryOneExcept(array(),					"\n" . $this->oPrefs->getOrSet(							'lang/en/broadcastLogonFailedGettingIP',							' -- didn\'t provide IP -- continue... ') . "\n");			return;		} // if error getting peer name		$sRemIP = long2ip(ip2long($sRemIP));		// check validity step 2 -> black list		$mRes = $this->passesIPblackList($sRemIP);		if (true !== $mRes) {			$this->write2resource($rSpawn, ((false == $mRes)					? $this->oPrefs->getOrSet('lang/en/goodbyeErrorBlackList',						'  sorry, connecting failed ') : $mRes));			@socket_close($rSpawn);			$this->tellEveryOneExcept(array(),					"\n" . sprintf($this->oPrefs->getOrSet(							'lang/en/broadcastLogonFailedBlackList',							' -- didn\'t pass IP black list -- continue... '),						$sRemIP) . "\n");			return;		} // if not passed black list		// check validity step 3 -> white list (optional)		$mRes = $this->passesIPwhiteList($sRemIP);		if (true !== $mRes) {			$this->write2resource($rSpawn, $mRes);			socket_close($rSpawn);			$this->tellEveryOneExcept(array(),					"\n" . sprintf($this->oPrefs->getOrSet(							'lang/en/broadcastLogonFailedWhiteList',							' -- didn\'t pass IP white list -- continue... '),						$sRemIP) . "\n");			return;		} // if not passed white list		// check validity step 4 -> add unknown user // uid		$sV = '20100429_103006';		$this->oPrefs->set('coreVersion', $sV);		$bLogItOn = false;		// now, possibly the client has already sent his uid...		if (!empty($sInput)) {			// quick check if it's correct			if (isset($this->aUo[$sInput])) {				$oUser = $this->aUo[$sInput];				if (!$oUser->isConnected()) {					// log him on					$bLogItOn = true;					$sWelcome = sprintf($this->oPrefs->getOrSet(						'lang/en/logonFinal', '  welcome %1$s'), $oUser->name()) . "\n";				} // if not already logged on			} // if valid uid		} // if possibly a quick logoner		// if we got this far, we add a new logon chatClient1'a2,o3.e		// write a welcome message to the client		/*$sWelcome = $this->oPrefs->getOrSet('lang/en/welcomeBanner',				".\n.\n  LAY DOWN THE GUNS, THANKS \n"				. "  _ ________,   ,________ _     \n"				. "  }`(==(----'   '----)==)`{     \n"				. " (__/~~`             `~~\\__)\n.\n.") . "\n"				. $this->oPrefs->getOrSet('lang/en/logonPrompt1',						'Hi, please input your case sensitive uid: ');			*//*			".\n.\n\n"			. "                                            888888b."			. "                   d8b          Y88b   d88P \n"			. " Talk to Me. And Pass the joint.:-)         888   88b"			. "                  Y8P           Y88b d88P  \n"			. "                                            888  .88P"			. "                                 Y88o88P   \n"			. " 888  888 888d888 .d88b.  888  888          8888888K.  "			. "888d888 8888b.  888 88888b.     Y888P    \n"			. " 888  888 888P   d88  88b `Y8bd8P           888   Y88b 888P"			. "        88b 888 888  88b    d888b    \n"			. " 888  888 888    888  888   X88K  888888    888    888 888"			. "    .d888888 888 888  888   d88888b   \n"			. " Y88b 888 888    Y88..88P .d8  8b.          888   d88P 888"			. "    888  888 888 888  888  d88P Y88b  \n"			. "   Y88888 888      Y88P   888  888          8888888P   888"			. "     Y888888 888 888  888 d88P   Y88b \n.\n.") . "\n" .*/		if (!$bLogItOn) $sWelcome = implode("\n", SssS_TextDecorator::centeredTextPages(				gmdate('r'))) . "\n"		. htmlspecialchars_decode($this->oPrefs->getOrSet('lang/en/welcomeBanner', htmlspecialchars(SssS_AnsiEscapes::gimme('greenOnBlack')		. ".                                                                             .\n"		. "                                                                               \n"		. "                     Talk to Me. And Pass the joint.:-)                        \n"		. "                                                                               \n"		. "                     888  888 888d888 .d88b.  888  888                         \n"		. "                     888  888 888P   d88  88b `Y8bd8P                          \n"		. "                     888  888 888    888  888   X88K  888888                   \n"		. "                     Y88b 888 888    Y88..88P .d8  8b.                         \n"		. "                       Y88888 888      Y88P   888  888                         \n"		. "              888888b.                                Y88b   d88P              \n"		. "              888   88b ~LukeZimmermann & ZendeLuna~   888b d88P               \n"		. "              888  .88P                                 Y88o88P                \n"		. "              8888888K.  888d888 8888b.  888 88888b.     Y888P                 \n"		. "              888   Y88b 888P        88b 888 888  88b    d888b                 \n"		. "              888    888 888    .d888888 888 888  888   d88888b                \n"		. "              888   d88P 888    888  888 888 888  888  d88P Y88b               \n"		. "              8888888P   888     Y888888 888 888  888 d88P   Y88b              \n"		. "                                                                               \n"		. ".                                                                             .\n")))		. SssS_AnsiEscapes::gimme()		. '         Copyright 2009 SwissalpS@LukeZimmermann.com : Creative Commons' . "\n"		. '             attributions non commercial, artistic & share alike.' . "\n"		. '                           Thank you for sharing :-)' . "\n                                 "		. SssS_AnsiEscapes::gimme('blackOnCyan') . $sV . SssS_AnsiEscapes::gimme() . "\n"		. htmlspecialchars_decode($this->oPrefs->getOrSet('lang/en/logonPrompt1',						'   Hi, please input your case sensitive uid: '));		$this->write2resource($rSpawn, $sWelcome);		if ($bLogItOn) {			$oUser->setResourceHandle($rSpawn); // act of logon			$oUser->set('lastConnectedIPtoBackEnd', $sRemIP);			$this->tellEveryOneExcept(array($oUser->uid()),					$oUser->name() . " has joined us\n");			if (3 < $this->oPrefs->get('debugLevel'))					echo 'logged on: ' . $oUser->name() . "\n";		} else {			// que up unknown visitor			$oNewUser = new SssS_ChatLogonClient($this);			$oNewUser->setResourceHandle($rSpawn);			$oNewUser->set('lastConnectedIPtoBackEnd', $sRemIP);			$this->aUoLogons[$oNewUser->uid()] = $oNewUser;		} // if logon or wait for input		// that's all since 20100429_131852 moved the rest around	} // logon	function newUIDlogon() { return strval(count($this->aUoLogons)); } // newUIDlogon	function passesIPblackList($sIP) {		if (in_array($sIP, array_merge(array(null),				$this->oPrefs->getOrSet('listIPblack',					array('0.0.0.0', '255.255.255.255'))))) {//, true, false, 1, 0var_dump($sIP, in_array($sIP, array_merge(array(null),				$this->oPrefs->getOrSet('listIPblack',					array('0.0.0.0', '255.255.255.255')))));//, false, true, 1, 0//return true;			return false;		} // if on black list		return true;	} // passesIPblackList	function passesIPwhiteList($sIP) {		if (!$this->oPrefs->getOrSet('useWhiteList', false)) return true;		return in_array($sIP, $this->oPrefs->getOrSet('listIPwhite',				array('127.0.0.1')));	} // passesIPblackList	function pidLock() {		// already instantiated? go home!		if ($this->oPID) return;		// attempt to initialize prefs if not yet done and die if can't		$this->initPrefs();		echo SssS_TextDecorator::indentLines('checking pid lock...', 5)				. "\n";		// get pid path or use null -> /var/run/scriptname.lock		$sName = $this->oPrefs->getOrSet('pid/lockName', $this->sUIDroom);		$sPIDpath = $this->oPrefs->getOrSet('paths/pidPath', 'data/');		$sExtLock = $this->oPrefs->getOrSet('pid/lockExtension', '.lock');		$sExtScript = $this->oPrefs->getOrSet('pid/scriptExtension', '.php');		$this->oPID = new SssS_PIDlock($sPIDpath, $sName, $sExtScript, $sExtLock);		// check pid lock and die if already running or set lock if not		if ($this->oPID->isLocked()) die(SssS_TextDecorator::indentLines(				SssS_AnsiEscapes::flatten(array('bold', 'blinking', 'bell',						'blackOnRed', 'already running with pid: ', 'blinkingOff',						$this->oPID->getPIDfromFile(), 'neutral',  "\n",						'bell',	'blackOnRed', 'according to pid file: '						. $this->oPID->getPIDLockPathFile(), 'neutral')), 5) . "\n");		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'pid lock ok', 'neutral')), 5)				. "\n\n";		unset($sPIDpath, $sExtScript, $sExtLock);	} // pidLock	function readClientInput($sUID = '') {		// invalid uid		if (!isset($this->aUo[$sUID])) return "\n" . 'invalid uid' . "\n" . '101';		$oUser = $this->aUo[$sUID];		if ($oUser->isConnected()) {			// read if there is anything - @ is important here			$mRes = @socket_recv(					$oUser->resourceHandle(), $sInput, 1024, MSG_DONTWAIT);			// did we get something?			if (false !== $mRes) $sInput = trim($sInput); // yes -> trim			if ($sInput && '' != $sInput) {				// got input				if (3 < $this->oPrefs->get('debugLevel')) {						echo "\n" . '-read successfully: ' . $mRes								. ' bytes' . "\n";						echo $oUser->name() . ' input: ' . $sInput . "\n";var_dump($sInput, ord($sInput));				} // if debug level 3.1+				// from terminal nothing is sent without an ending \n				// but streams could send any number of chars.				// for now, just assume line by line input so input ends with \n				// but as it's trimmed, the end is clean or has a \				if ('\\' == substr($sInput, -1)) {					$oUser->sStackIn .= str_replace("\\\n", "\n",												substr($sInput, 0, -1)) . "\n";					$sInput = '';					return;				} // if 'ending in an escaped newline'				//else {				$sInput = $oUser->sStackIn . str_replace("\\\n", "\n", $sInput);				$oUser->sStackIn = '';				//}				$iLenInput = strlen($sInput);				$sI0 = (0 < $iLenInput) ? $sInput{0} : '';				if (4 == ord($sInput)) {					// this is returned when a user eg closes his terminal window					echo "\n" . 'abrupt connection termination: ' . $oUser->uid() . "\n";					$this->kickUser($sUID);				} elseif (self::COMM_CHAR_INTERNAL == $sI0 && 1 < $iLenInput) {					// got command comming up					$mRes = $this->oCommander->runCommandLine(							substr($sInput, 1), $oUser);					if (1 < $this->oPrefs->get('debugLevel')) echo $mRes;					$this->write2Client($sUID, $mRes . "\n");				} elseif (self::COMM_CHAR_RUNF == $sI0 && 1 < $iLenInput) {					// got sh command comming up					$mRes = $this->oCommander->command_runf(explode(' ', substr($sInput, 1)), $oUser);					if (1 < $this->oPrefs->get('debugLevel')) echo $mRes;					$this->write2Client($sUID, $mRes . "\n");					//$this->write2Client($sUID, $mRes . "\n");				} elseif (self::COMM_CHAR_PHP == $sI0 && 1 < $iLenInput) {					// got php snippet comming up					$mRes = $this->oCommander->command_shell(array(substr($sInput, 1)), $oUser);//explode(' ', )					if (1 < $this->oPrefs->get('debugLevel')) echo $mRes;					$this->write2Client($sUID, $mRes . "\n");				} else {					// normal message					// tell others					$sFormat = $oUser->getOrSet('promptString', '%1$s: %2$s');					$sOut = sprintf($sFormat . "\n", $oUser->name(), $sInput);					// not sender! unless user may want echo					$aDispatchTo = ($oUser->getOrSet('echoMyInput', false))							? array() : array($sUID);					$sColoured = SssS_AnsiEscapes::gimme('bell')							. SssS_AnsiEscapes::gimme(								$oUser->get('colourEscape', 'neutral'))							. $sOut . SssS_AnsiEscapes::gimme();					$this->tellEveryOneExcept($aDispatchTo, $sColoured);				} // if command or message			} // got input		} // if got a resource handle for given uid	} // readClientInput	// 20100429_114628	function readLogonInput($sUID = '') {		// invalid uid		if (!isset($this->aUoLogons[$sUID]))				return "\n" . 'invalid uid' . "\n" . '101';		$oUserLogon = $this->aUoLogons[$sUID];		if (8 < $this->oPrefs->get('debugLevel'))				echo "\n" . "reading input from: " . $oUserLogon->name() . "\n";		$bLogItOn = false;		if ($rSpawn = $oUserLogon->resourceHandle()) { //$oUserLogon->isConnected()) {			// read if there is anything - @ is important here			$mRes = @socket_recv($rSpawn, $sInput, 1024, MSG_DONTWAIT);			// did we get something?			if (false !== $mRes) $sInput = trim($sInput); // yes -> trim			if ($sInput && '' != $sInput) {				// got input				// possibly a browser? or other client?				if (self::isHTTPrequest($sInput)) {					$this->dealWithHTTP($rSpawn, $sInput);					@socket_close($rSpawn);					unset($this->aUoLogons[$sUID]);					return;				} // if browser				if (3 < $this->oPrefs->get('debugLevel')) {						echo "\n" . '-read successfully: ' . $mRes								. ' bytes' . "\n";						echo $oUserLogon->name() . ' input: ' . $sInput . "\n";				} // if debug level 3.1+var_dump($sInput, ord($sInput));				if (4 == ord($sInput)) {					// this is returned when a user eg closes his terminal window					echo "\n" . 'abrupt connection termination: '							. $oUserLogon->uid() . "\n";					$oNewUser->setResourceHandle(); // so it get's removed on next iteration				} else {					// got response					if (isset($this->aUo[$sInput])) {						// valid id						$oUser = $this->aUo[$sInput];						if (!$oUser->isConnected()) {							// log him on							$bLogItOn = true;							$sWelcome = sprintf($this->oPrefs->getOrSet(									'lang/en/logonFinal', '  welcome %1$s'),										$oUser->name());						} else {							// try again							$sWelcome = $this->oPrefs->getOrSet(									'lang/en/logonUIDalreadyLoggedOn',									'    Sorry, that wasn\'t it. That ID is logged on already.');						} // if not yet connected					} else {						// try again						$sWelcome = $this->oPrefs->getOrSet(								'lang/en/logonUIDnonExistant',								'    Sorry, that wasn\'t it. It doesn\'t exist');					} // if valid id or not					if ($bLogItOn) { // $oUser is valid and not yet logged on						$this->write2resource($rSpawn, $sWelcome . "\n");						$oUser->setResourceHandle($rSpawn); // act of logon						$oUserLogon->setResourceHandle();						$oUser->set('lastConnectedIPtoBackEnd',								$oUserLogon->get('lastConnectedIPtoBackEnd'));						//$oUserLogon->logout();						unset($this->aUoLogons[$sUID]);						$this->tellEveryOneExcept(array($oUser->uid()),								$oUser->name() . " has joined us\n");						if (3 < $this->oPrefs->get('debugLevel'))								echo 'logged on: ' . $oUser->name() . "\n";					} else {						// try again or kick it off //TODO: get max logon count from prefs						if (3 > ++$oUserLogon->iLogonAttemptCount) {							// try again							$sWelcome .= "\n" . htmlspecialchars_decode(									$this->oPrefs->getOrSet(											'lang/en/logonPrompt2',											'   please input your case sensitive uid: '));							$this->write2resource($rSpawn, $sWelcome);						} else {							// kick it off							$this->write2resource($rSpawn, $sWelcome . "\n"									. $this->oPrefs->getOrSet(											'lang/en/logonFailBye',											'		Goodbye.') . "\n");							if (3 < $this->oPrefs->get('debugLevel'))									echo 'kicking off client after ' .									--$oUserLogon->iLogonAttemptCount									. ' attempts. IP: '									. $oUserLogon->get('lastConnectedIPtoBackEnd')									. "\n";							socket_close($rSpawn); // $oUserLogon->logout();							unset($this->aUoLogons[$sUID]);						} // if try again or kick it off					} // if log it on or {try again or kick off}				} // if what kind of input			} // if input at all		} else {			// not online			unset($this->aUoLogons[$sUID]);			if (3 < $this->oPrefs->get('debugLevel'))					echo "\n" . '-removed dead logon client: ' . $sUID . "\n";		} // if online or not	} // readLogonInput	function requestLinup() {	} // requestLinup	function run() {		$this->initServer();		if (!$this->bInitiated)				$this->shutdown("\n" . 'init failed' . "\n" . '201');		// start listening		$this->bRunning = true;		echo SssS_TextDecorator::indentLines(SssS_AnsiEscapes::flatten(array(				'blackOnGreen', 'bold',	'entering default run loop', 'neutral')), 5)				. "\n\n";		while (true) {			// listen to parent server			//$this->			// listen to god connection			//$this->			//->done in acceptClient			// might want to parse an array of connected and use socket_select trigger for possibly better performance -> leaves de-parsing again to having an aSockets[ip]=socket;aIPs[socket]=ip; kinda thing like in nanoweb			// need to consider reading stdin, that would mean to first check if we are running in background etc. I think it's ok this way			foreach($this->aUo as $sUID => $oUser) {				if ($oUser->isConnected()) {					// give user a chance to say/ask something					$this->readClientInput($sUID);				} else {					// give a brief chance of connecting new users or front end					//  http(s) frontends)					$this->acceptClient(false); //true); //				} // if online			} // foreach user			foreach($this->aUoLogons as $sUID => $oUserLogon) {				if ($oUserLogon->isConnected()) $this->readLogonInput($sUID);			} // foreach unknown user			usleep(5000); // maybe this helps maybe it hurts -> find out TEST:		} // while no one tells us not to by other means	} // run	function saveServer() {		$this->oPrefs->save();		$this->oPusers->set('/', array_keys($this->aUo));		$this->oPusers->save();		$this->oCommander->save();//		$this->oEmmotion->save();	} // saveServer	function shutdown($sMsg = "\n!!! -shutting down instantly- !!!\n") {		$mRes = $this->tellEveryOneExcept(array(), $sMsg);		if (3 < $this->oPrefs->get('debugLevel')) var_dump($mRes);		$this->bInKillLoop = true;		$aUIDs = array_keys($this->aUo);		foreach($aUIDs as $sUID) {			$this->kickUser($sUID);		} // foreach user		foreach($this->aUoLogons as $oUserLogon) {			$oUserLogon->logout();		} // foreach unknown user		// TODO: tell parent server that we're shutting down		// close primary socket		@socket_shutdown($this->rSocket, 2); // shutdown r&w		socket_close($this->rSocket);		echo "\n" . gmdate('Ymd h:i:s') . "\n" . $sMsg . "\n"				. " Socket terminated\n";		// save settings		$this->saveServer();		// unlock pid		$this->oPID->unLock();		exit(0);	} // shutdown	function tellEveryOneExcept($aUIDs, $sMsg = '') {		// check if we are online at all		if (!$this->bRunning) return "\n"				. 'not running, can\'t tell no one about:' . "\n" . $sMsg				. "\n" . '104';		// console/log output for debugging		if (3 < $this->oPrefs->get('debugLevel'))				echo "\n" . 'broadcast: ' . $sMsg . "\n";		if (0 < count($this->aUo)) {			foreach($this->aUo as $sUID => $oUser) {				if (!in_array($sUID, $aUIDs)) {					// TODO: filter out those that are not yet logged on					// send					$this->write2Client($sUID, $sMsg);				} // if not excempt			} // foreach user		} // if got any	} // tellEveryOneExcept	private function waitNreadResource($rSpawn) {		if (3 < $this->oPrefs->get('debugLevel'))				echo "\n" . 'waiting for input...';		while (true) { // this while is just in case we aren't blocking			// here the @ is not so important as we are probably blocking			$mRes = @socket_read($rSpawn, 1024, PHP_NORMAL_READ);			if (false === $mRes) { // error				if (3 < $this->oPrefs->get('debugLevel')) {					echo ' reading failed: '							. socket_strerror(socket_last_error($rSpawn)) . "\n";				} // if debug output				return false;			} // if error			$sInput = trim($mRes);			if ('' != $sInput) {				// got input				if (3 < $this->oPrefs->get('debugLevel')) echo ' input: ' . $sInput . "\n";				return $sInput;			} // got input		} // loop n wait	} // waitNreadResource	function write2Client($sUID, $sMsg = '') {		// check if we are online at all		if (!$this->bRunning) return "\n" . 'not running' . "\n" . '104';		// check user		if (!isset($this->aUo[$sUID])) return "\n" . 'invalid uid' . "\n" . '101';		$oUser = $this->aUo[$sUID];		if (!$oUser) return "\n" . 'user not registered' . "\n" . '103';		// drop in dropBox anyway		$oUser->dropBox(trim($sMsg));		// if not online		if (!$oUser->isConnected())				return "\n" . 'user isn\'t here' . "\n" . '102';		return $this->write2resource($oUser->resourceHandle(), $sMsg);	} // write2Client	private function write2resource($rHandle, $sMsg) {		$iOffset = 0;		$iLen	 = strlen($sMsg);		while ($iOffset < $iLen) {			$mSent = @socket_write(					$rHandle, substr($sMsg, $iOffset), $iLen - $iOffset);			if (false === $mSent) {				// Error occurred, break the while loop				break;			} // if unable to send			$iOffset += $mSent;		} // while buffer to send		/* above works better than the simple one liner bellow		socket_write($aUo[$sUID], $sMsg, strlen ($sMsg)) or die("Could not send connect string\n");		*/		// catch premature break		if ($iOffset < $iLen) {			$iErrorCode = socket_last_error();			$sErrorMsg = socket_strerror($iErrorCode);			// find culprit and kick him off so he can log on again			$bFound = false;			foreach ($this->aUo as $oUser) {				if ($oUser->resourceHandle() == $rHandle) {					$oUser->logout(); $bFound = true; break;				} // if found			} // foreach user			if (!$bFound) @socket_close($rHandle);			if (0 < $this->oPrefs->get('debugLevel'))					echo "\n" . gmdate('Ymd h:i:s')					. ' SENDING ERROR: ' . $sErrorMsg . "\n"					. (($bFound) ? ' found and dropped culprit'						: ' failed to find culprit, possibly not yet logged on')					. "\n";		} else {			// Data sent ok			if (3 < $this->oPrefs->get('debugLevel'))					echo "\n" . '-Sent output ok: ' . $sMsg . "\n";		} // if premature break or ok	} // write2resource	function __toString() { return print_r($this, true); } // __toString	// rough checking for http requests	static function isHTTPrequest($sSubject) {		$sPattern = '!'			. '(GET|POST|HEAD|OPTIONS|PUT|DELETE|TRACE|CONNECT'			. '|PROPFIND|PROPPATCH|MKCOL|COPY|MOVE|LOCK|UNLOCK'			. '|VERSION-CONTROL|REPORT|CHECKOUT|CHECKIN'			. '|UNCHECKOUT|MKWORKSPACE|UPDATE|LABEL|MERGE'			. '|BASELINE-CONTROL|MKACTIVITY|ORDERPATCH'			. '|ACL|PATCH|SEARCH' . ')'			. '([ \t])+'			. '([^\t(HTTP)]+)?'			. '([ \t])+'			. '(HTTP\/1(.*))!';		$aLines = explode(chr(10), $sSubject);		$sFirstLine = $aLines[0];		return (preg_match($sPattern, $sFirstLine));	} // isHTTPrequest} // SssS_SocketController/* * * *\ SssS_SocketController.inc (CC) Luke JZ aka SwissalpS /* * * */?>